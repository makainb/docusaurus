## 持续集成

### 日程
- 持续集成缘何而来
- 敏捷，持续集成，持续交付，DevOps 的区别
- 为什么需要做持续集成
- 如何设计持续集成流水线

### 持续集成缘何而来
- 敏捷开发解决了单体应用的开发和每日构建的问题。
- 单体应用拆分成微服务，就需要有方法来组装这些微服务，成为可联合运行的微服务架构。这个方法就是持续集成

### 持续集成定义
- 持续交付的鼻祖Martin Fowler提出：持续集成(Continous Integration)其实是一种软件开发实践，帮助团队成员频繁地集成他们的工作，通常每个项目每天至少集成一次，从而每天有可测试的版本。
- 每次集成使用自动化构建（含测试）来实现打包和测试，快速验证问题。 许多团队发现持续集成显著地降低了集成遇到的错误，使团队能够更加迅速地开发软件。

### 敏捷，持续集成，持续交付，DevOps 的区别
```
敏捷开发：计划 -> 代码 -> 构建
持续集成：计划 -> 代码 -> 构建 -> 测试
持续交付：计划 -> 代码 -> 构建 -> 测试 -> 发布
持续部署：计划 -> 代码 -> 构建 -> 测试 -> 发布 -> 部署
DevOps ：计划 -> 代码 -> 构建 -> 测试 -> 发布 -> 部署 -> 部署 -> 运维监控
```

敏捷开发：从计划定义，拆解，分配到构建
持续集成：比敏捷多了一个自动化测试，跑自动化测试用例
持续交付：比持续集成多了一个制品交付，上传到Nexus
持续部署：比持续交付多了一个部署一次环节
DevOps: 包含了软件周期的所有环境，包含环境监控

### 需要进行持续集成的原因

- 以前我们的应用是单体应用，单体应用部署相对简单
- 微服务模式下应用部署的复杂度高
- git代码库：把代码整合到一起
- 持续构建：把代码的功能放在一起，保证编译不出错
- 自动化测试：一个模块的功能集成在一起，能够正常工作
- 联调测试环境：需要将不同模块之间集成在一起，在一个类生产的环境中进行测试

### 如果设计持续集成流水线
![111](/attr/pm/flow-design.png)

![111](/attr/pm/jenkins-flow.png)


## 互联网公司如何进行持续部署

### 日程
- 为什么要做持续部署
- 持续部署的定义
- 持续部署的常见方法


### 为什么需要持续部署
- 传统部署部署方式依赖手工部署
- 生产环境依赖手工配置进行变更
- 熬夜加班进行上线部署

### 持续部署的定义
- 软件部署：将软件按照期望的状态，部署到目标机器上的期望路径。
- 持续部署：自动化的将一个或多个软件尽可能快的，稳定的，可重复的联合部署到目标机器，以便进行软件功能的验证和实际运行。可能是在云环境中自动部署、app升级（如手机上的应用程序）、更新网站或只更新可用版本列表。

### 持续部署的要素
- 自动化部署 - ansible
- 应用与配置分离，一次构建，多处运行 - Spring Cloud Nacos, 
- 提供应用健康监测的接口 - Spring Cloud Actuator

### 程序的发布方式
- 滚动发布
- 蓝绿发布
- 金丝雀发布
- 灰度发布
- A/B测试
- 功能开关

### 功能开发
- 对于可能需要轻松关掉的新功能（如果发现问题），开发人员可以添加功能开关(feature toggles)。这是代码中的 if-then 软件功能开关，仅在设置数据值时才激活新代码。
- 此数据值可以是全局可访问的位置，部署的应用程序将检查该位置是否应执行新代码。如果设置了数据值，则执行代码；如果没有，则不执行。
- 这为开发人员提供了一个远程“终止开关”，以便在部署到生产环境后发现问题时关闭新功能。

前几天的小红书就是这么出事的，还有王者的内挂。
https://blog.csdn.net/a15835774652/article/details/145905439


-----

https://github.com/haxqer/jira

JIRA 敏捷项目管理架构
◆ Release（发布，单位为月）
  ◆ Sprint（冲刺，单位为周）
    ◆ Issue（问题）类型
      ◆ Epic（史诗）
      ◆ Story（用户故事）
      ◆ Task（任务）
      ◆ Bug（故障）

敏捷解决的问题：把一个目标拆分、细化、评估变成一个合理的、可完成的一个项目。让大家在一个合理的工作压力下，进行发布Release的实现，不断的细化。

Epic：老板的规定，一个目标
Story：用户故事就是描述需求，做什么事情 ，达到什么目的，产品经理拆分成Task
Task：可执行任务，程序猿接到后针对自己手里的任务进行开发排期，进行上线
Bug：测试人员会测试出来很多BUG，让程序猿进行修复

创建Release
创建Sprint
创建用户故事
创建任务，并分配给工程师

Jira 创建一个Release（发布版本）
- Release（版本）的时间跨度通常为1-3个月
- 版本多含多个Sprint（冲刺）
- Release 里会清晰定义需要完成的开发任务


Jira创建一个Sprint
- Sprint 需要关联到开发的任务
- Sprint 需要被关联到某一个 Release

Jira 创建一个用户故事  
- 定义用户故事的类型
- 定义用户故事的内容描述

从用户来描述的需求，粒度较粗。比如：作为一个用户，我想要看到一个周报表，跟我的Excel差不多。


为用户故事创建一个任务  
- 定义任务内容描述
- 分配给某个开发者
- 设定任务期望完成的时间
- 将任务关联到用户故事
- 将任务放入Sprint中

```
项目：
问题类型：任务
汇总：修改页面
报告人：马凯
模块：无
描述：
目标Excel为附件，
字段解析：
重量：为BOM页面中的重量

流程解析：
XXX
```

通过Sprint Dashboard 查看任务

---

## 任务的排期与追踪，保证到期能上线

### 日程
- 查看 Release 版本信息
- 查看 Sprint
- 查看 Sprint 各个任务的进度
- 每日站会如何开

### 为任务预估 Story Point
用1，2，3到10个点数来评估任务的故事点
- 工作量
- 复杂度
- 风险和不确定性

### 将任务状态从待办变成处理中

看板：把任务从待办移动到处理中

### 为项目创建任务燃尽图
完成一个任务时，燃尽图会更新。能看出是不是因为时间紧 ，BUG很多。还是时间不紧，质量很高。

### 每日站会
- Scrum Master 主持
- 建议每日早上举行
- 每人回答3个问题
  - 昨天做了什么
  - 今天要做什么
  - 有什么 Blocker 问题，需要什么帮助

目的：避免不确定的风险，能够将不确定的风险提高暴露出来。快速暴露风险


---

## 在开发工具里集成 Jira 插件

### 日程
- 在 Idea 里集成 Jira 插件
- 在 Idea 里快速获取自己的开发任务
- 通过插件创建分支，开发代码
- 提交代码并更改 Jira 任务状态

### 在 IDEA 里集成 Jira 插件
IDEA版本：
Jira插件：
配置：在 Tools -> Tasks -> Servers 中输入 `url` ，`username` 和 `password` 。

### 将任务状态变为处理中，并创建开发分支
会触发两个操作：
- 操作远程的任务状态为 **处理中** 
- 将本地的此次操作创建一个**分支** ，从**main**分支拉取


### 根据任务ID创建分支
在IDEA的Terminal里会自动将分支切换到XXX

### 编写代码，提供代码
开发者进行代码编写，完成编码后提交代码到分支 NOT-2

```
git add .
git commit -a -m "fix docs"
git push
```

### 全并代码到 Master 分支
本地测试，验证功能之后提交 Merge Request, 合并到Master分支
```
git checkout master
git merge NOT-2
```

---

## Gitflow VS Trunk base 分支模型哪个更适合我们的团队？

### 今日知识
- 什么是 Gitflow 以及特性
- 什么是主干开发模式以及特性
- Gitflow VS 主干开发模式

## Gitflow
### Gitflow 介绍以及特性

- Master 主分支
- develop 开发分支
- feature 功能分支
- release 版本分支
- hotfix Bug修复分支

> Gitflow 是一种分支开发模型，来源于 Vincent Driessen 的文章 “A successful Git branching model”，这是一套非常成熟的分支模型。

### master 分支
master 分支的 head 始终保持具备生产部署的状态
master 分支现在改名为 main 分支（拜登在的时候搞的黑命贵）

### develop 分支
- 包含所有最新的，可发布的变更，也叫集成分支。
- 当从 develop 发布到 Release 分支时，变更需要合并的 master 分支。

### feature 分支
- 可能基于 develop 创建。
- 必须合并回归到 develop。
- 分支命名：除了叫 master, develop, release-, or hotfix-，其他都可以。

### release 发布分支
- 可能基于 develop 创建。也可以基于 master 创建
- 必须合并回归到 develop，master。
- 分支命名: release-*。

### hotfix分支
- 可能基于 master 创建。
- 必须合并回归到 develop，master。
- 分支命名: hotfix-*。

### Gitflow 适用场景
- 软件本身对稳定性要求高
- 团队少量资深研发，多数初，中级研发
- 开源项目
- 大多数项目都适合该模型



## 主干开发分支

### 主干开发分支模型
- 来源于 facebook
- 同一个产品开发的所有人员共享一个Repository，所有修改最后都会回到主干
- 只有在Release时才会有官方的分支，只有Release Engineer可以更动Release Branch，当Release Branch完成它的任务，就会被砍掉
- Bug先在trunk修复，之后把Commit合并到Release Branch，而不是在Release Branch修好再整合到trunk，这样可以把修改Release Branch的人限制在最小程度。

### 功能开关
- 将功能上线，但是不开放给用户
- 当功能反正发布了，在下一次 Release 打开开关
- 每个功能开关可以被远程触发，实时生效

```java
if (FeatureManager.isFeatureEnabled("NewLoginForm")) {
    openNewLoginForm();
} else {
    openOldLoginForm();
}
```

### 适用场景

- 软件本身迭代较快
- 团队中级，资深研发较多，初级研发较少
- 互联网产品