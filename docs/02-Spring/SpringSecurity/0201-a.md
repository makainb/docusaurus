---
draft: true
sidebar_class_name: hidden-sidebar-item
---

## 自定义用户查询

UserDetailsService#loadUserByUsername

## 自定义用户对象

```java
public interface UserDetails extends Serializable {

    Collection<? extends GrantedAuthority> getAuthorities();//获取所有权限

    String getPassword();// 获取密码

    String getUsername();//获取用户名

    boolean isAccountNonExpired(); //账号是否过期

    boolean isAccountNonLocked();// 账号是否被锁定

    boolean isCredentialsNonExpired()// 凭证（密码）是否过期

    boolean isEnabled(); // 是否启用
}
```

## 如果没有找到用户
```
UsernameNotFoundException
```

## 密码加密
```java
@Bean
public PasswordEncoder passwordEncoder() {
    // return new BCryptPasswordEncoder();
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
```

## 自定义成功信息
从AuthenticationSuccessHandler接口继承
```java
http.formLogin(form -> {
    form.successHandler(new MyAuthenticationSuccessHandler());
})
```

## 自定义失败信息
从AuthenticationFailureHandler接口继承
```java
http.formLogin(form -> {
    form.failureHandler(new MyAuthenticationFailureHandler());
})
```

## 用户退出处理
```java
从LogoutSuccessHandler接口继承
http.logout(logout -> 
    logout.logoutSuccessHandler(new MyLogoutSuccessHandler());
);
```

## 没有认证处理
从AuthenticationEntryPoint接口继承
```java
http.exceptionHandling(exception -> 
    exception.authenticationEntryPoint(new MyAuthenticationEntryPoint());
)
```

## 自定义login登录
```java
UsernamePasswordAuthenticationToken authenticationToken = UsernamePasswordAuthenticationToken.unauthenticated(username, password);
Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
if(authentication == null || !authentication.isAuthenticated()){
    throw new BadCredentialsException("用户名或密码错误");   
}
// 保存用户信息
SecurityContextHolder.getContext().setAuthentication(authentication);

```






---------








当然可以！这正是现代前后端分离项目（尤其是配合 JWT 使用时）的主流做法。

要实现“无状态（Stateless）”，你需要做两件事：

1. **禁用 Session 保存状态**：告诉 Spring Security 不要往 Cookie 里塞 `JSESSIONID`。
2. **自定义 Filter**：手动从 Header（比如 `Authorization`）中提取令牌并校验。

### 1. 修改配置：开启无状态模式

在你的 `SecurityConfiguration.java` 中，添加 Session 管理策略的配置：

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    // 1. 禁用 Session（关键！）
    http.sessionManagement(session -> 
        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
    );

    // 2. 禁用 CSRF（无状态下通常不需要，你已经禁用了）
    http.csrf(AbstractHttpConfigurer::disable);

    // 3. 登录处理（如果是无状态，通常需要自定义登录接口返回 Token，
    // 或者继续用 formLogin 但要在成功处理器里返回 Token）
    http.formLogin(form -> {
        form.successHandler((request, response, authentication) -> {
            // 在这里生成你的 Token (例如 JWT)
            String token = "mock-token-123"; 
            writeJson(Map.of("code", "0", "token", token), response);
        });
    });

    // ... 其他配置
    return http.build();
}

```

---

### 2. 为什么只配置 `STATELESS` 还不够？

当你把 Session 关掉后，Spring Security 就像得了“失忆症”。用户第一次登录成功了，但第二次请求过来时，因为没有 Cookie 里的 `JSESSIONID`，Spring 认不出他是谁。

**你需要自己写一个“认人”的过滤器。**

### 3. 实现自定义 Header 过滤器

你需要创建一个类，继承 `OncePerRequestFilter`，每次请求都检查 Header：

```java
@Component
public class TokenFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 1. 从 Header 拿 Token
        String token = request.getHeader("Authorization");

        // 2. 简单的 Mock 验证逻辑 (实际应替换为 JWT 校验)
        if ("mock-token-123".equals(token)) {
            // 如果 Token 对了，手动把用户信息塞进 Security 上下文
            // 这里的 SessionUser 就是你之前写的那个类
            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken("admin", null, new ArrayList<>());
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        // 3. 放行
        filterChain.doFilter(request, response);
    }
}

```

### 4. 把过滤器挂载到 Spring Security 中

回到 `SecurityConfiguration.java`，把你的 `TokenFilter` 插到账号密码过滤器之前：

```java
@Autowired
private TokenFilter tokenFilter;

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    // ... 其他配置
    
    // 在用户名密码拦截器之前执行我们的 Token 拦截器
    http.addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class);
    
    return http.build();
}

```

---

### 这样修改后的效果：

1. **登录成功**：返回结果里不再只有“成功”，而是带上一个 `token`。
2. **后续访问**：前端需要把这个 `token` 放在请求头（Header）里送过来。
3. **服务器端**：不再开辟 Session 内存，完全靠解析 Header 里的内容来识别用户。

**你目前是打算用 JWT（JSON Web Token）来实现这个无状态方案吗？如果是，我可以帮你写具体的 Token 解析代码。**









