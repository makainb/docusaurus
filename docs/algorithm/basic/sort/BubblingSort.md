---
title: 冒泡排序
sidebar_position: 2
---

## 算法思路
0~i范围上，相邻位置较大的数冒下去，最大值最终来到i位置，然后0到i-1范围继续。

## 算法步骤

原始数组：[5, 3, 4, 1, 2]  

第1轮：0到4的下标上数开始两两交换，最大的数往右边冒  
第1轮第1比：5和3比较，5大 变成[3,5,4,1,2]  
第1轮第2比：5和4比较，5大 变成[3,4,5,1,2]  
第1轮第3比：5和1比较，5大 变成[3,4,1,5,2]  
第1轮第4比：5和2比较，5大 变成[3,4,1,2,5]  
第1轮结果：[3,4,1,2,5] 

第2轮：0到3的下标上数开始两两交换，最大的数往右边冒  
步骤省略...  
第2轮结果：[3,1,2,4,5]

第3轮：0到2的下标上数开始两两交换，最大的数往右边冒  
步骤省略...  
第3轮结果：[1,2,3,4,5]

第4轮：0到1的下标上数开始两两交换，左边小于右边，不用冒  
步骤省略...  
第4轮结果：[1,2,3,4,5]

此时只剩一个0的位置，不用换了，排序完成。


## 算法代码
```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }

    for (int end = arr.length - 1; end > 0; end--) {
        for (int i = 0; i < end; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
            }
        }
    }
}
```

## 测试方法
```java
public static void main(String[] args) {
    int[] arr = {5, 3, 4, 1, 2};
    bubbleSort(arr);
    print(arr);
}
```

## 时间复杂度
