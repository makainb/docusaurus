---
title: 快速入门-自定义用户与认证流程
sidebar_position: 0201
draft: true
sidebar_class_name: hidden-sidebar-item
---

## 本篇目标

这篇是从“能登录”到“能落地”的关键一步，目标是：

1. 使用数据库用户替换默认 `user` + 随机密码。
2. 理清 `UserDetailsService -> AuthenticationManager -> SecurityContext` 认证链路。
3. 统一登录成功、失败、未登录、无权限、退出的返回格式。
4. 为后续 JWT 无状态认证打基础。

## 1. 自定义用户查询入口

Spring Security 的默认入口是：

```java
UserDetailsService#loadUserByUsername(String username)
```

你需要在这里完成“按用户名查询用户 + 查询权限”，并返回 `UserDetails`。

如果用户不存在，必须抛出：

```java
throw new UsernameNotFoundException("用户不存在");
```

## 2. 自定义用户安全对象

`UserDetails` 是 Security 内部使用的标准用户模型，核心信息包括：

1. 用户名、密码
2. 权限集合（`GrantedAuthority`）
3. 账号是否过期/锁定/禁用

示例：

```java
public class SecurityUser implements UserDetails {
    private final Long id;
    private final String username;
    private final String password;
    private final boolean enabled;
    private final Collection<? extends GrantedAuthority> authorities;

    public SecurityUser(Long id, String username, String password, boolean enabled,
                        Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.enabled = enabled;
        this.authorities = authorities;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }
}
```

## 3. 实现 UserDetailsService

```java
@Service
public class DbUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public DbUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("用户不存在"));

        // 这里按你的库表模型组装角色/权限
        List<SimpleGrantedAuthority> authorities =
            List.of(new SimpleGrantedAuthority("ROLE_USER"));

        return new SecurityUser(
            user.getId(),
            user.getUsername(),
            user.getPassword(),
            user.getEnabled(),
            authorities
        );
    }
}
```

## 4. 密码加密配置

推荐使用 `BCrypt`：

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

如果你需要兼容历史前缀（如 `{bcrypt}`），可以改用：

```java
return PasswordEncoderFactories.createDelegatingPasswordEncoder();
```

## 5. 统一登录与异常处理

你已经在草稿里覆盖了关键 Handler，这里整理成一套完整配置：

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http,
                                       AuthenticationSuccessHandler successHandler,
                                       AuthenticationFailureHandler failureHandler,
                                       LogoutSuccessHandler logoutSuccessHandler,
                                       AuthenticationEntryPoint authenticationEntryPoint,
                                       AccessDeniedHandler accessDeniedHandler) throws Exception {
    http
        .csrf(AbstractHttpConfigurer::disable)
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/login", "/logout").permitAll()
            .anyRequest().authenticated()
        )
        .formLogin(form -> form
            .loginProcessingUrl("/login")
            .successHandler(successHandler)
            .failureHandler(failureHandler)
        )
        .logout(logout -> logout
            .logoutUrl("/logout")
            .logoutSuccessHandler(logoutSuccessHandler)
        )
        .exceptionHandling(ex -> ex
            .authenticationEntryPoint(authenticationEntryPoint)
            .accessDeniedHandler(accessDeniedHandler)
        );

    return http.build();
}
```

对应关系：

1. `AuthenticationSuccessHandler`：登录成功返回。
2. `AuthenticationFailureHandler`：登录失败返回。
3. `AuthenticationEntryPoint`：未登录访问受保护资源。
4. `AccessDeniedHandler`：已登录但权限不足（403）。
5. `LogoutSuccessHandler`：退出登录返回。

## 6. 自定义登录接口（可选）

如果你不走默认表单，也可以手动调用 `AuthenticationManager`：

```java
UsernamePasswordAuthenticationToken token =
    UsernamePasswordAuthenticationToken.unauthenticated(username, password);

Authentication authentication = authenticationManager.authenticate(token);
if (authentication == null || !authentication.isAuthenticated()) {
    throw new BadCredentialsException("用户名或密码错误");
}

SecurityContext context = SecurityContextHolder.createEmptyContext();
context.setAuthentication(authentication);
SecurityContextHolder.setContext(context);
```

如果当前仍是有状态会话模式（Session），别忘了把 `SecurityContext` 存回会话。

## 7. 过渡到无状态（JWT）时要改什么

当你准备从 Session 切到 JWT 时，最关键是两步：

1. 关闭会话状态：

```java
http.sessionManagement(session ->
    session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
);
```

2. 加入自定义 Token 过滤器：

```java
http.addFilterBefore(tokenFilter, UsernamePasswordAuthenticationFilter.class);
```

这样后续请求就不再依赖 `JSESSIONID`，而是依赖请求头中的 Token。

## 小结

到这里你已经具备了“企业常见登录链路”的核心能力：

1. 自定义用户查询（`UserDetailsService`）
2. 密码加密校验（`PasswordEncoder`）
3. 登录与异常统一返回（各类 Handler）
4. 手动认证与上下文维护（`AuthenticationManager` + `SecurityContext`）

下一篇可以继续写：**基于 JWT 的无状态认证实战（含过滤器与 Token 刷新）**。
